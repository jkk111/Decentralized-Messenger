<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/paper-drawer-panel/paper-drawer-panel.html">
<link rel="import" href="/bower_components/paper-header-panel/paper-header-panel.html">
<link rel="import" href="/bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="/bower_components/paper-menu/paper-menu.html">
<link rel="import" href="/bower_components/paper-input/paper-input.html">
<link rel="import" href="/bower_components/paper-item/paper-item.html">
<link rel="import" href="/bower_components/paper-material/paper-material.html">
<link rel="import" href="/bower_components/paper-input/paper-textarea.html">
<link re;="import" href="/bower_components/iron-pages/iron-pages/html">
<link rel="improt" href="/bower_components/iron-icons/iron-icons.html">
<link rel="improt" href="/bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="/bower_components/paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="contact-element.html">

<dom-module id="messenger-view">
  <style>
    paper-menu {
      padding-top: 0;
    }
    paper-dialog-scrollable {
      height:400px;
    }
    paper-toolbar {
      background-color: #4CAF50;
    };
  </style>
  <template>
    <iron-ajax id="pollajax" url="/messages" method="Post" content-type="application/x-www-form-urlencoded"
               body="{{messagesBody}}" handle-as="json" on-response="pollResponse">
               </iron-ajax>
    <iron-ajax id="friendsajax" url="/getFriends" method="Post" content-type="application/x-www-form-urlencoded"
               body="{{messagesBody}}" handle-as="json" on-response="friendsResponse">
               </iron-ajax>
    <iron-ajax id="messageAjax" url="/message" method="Post" content-type="application/x-www-form-urlencoded"
               body="{{messageBody}}" handle-as="json" on-response="messageSentResponse">
    </iron-ajax>
    <paper-drawer-panel>
      <paper-header-panel drawer>
        <paper-toolbar>
          <div class="title">Friends</div>
        </paper-toolbar>
        <div id="drawerContent">
          <paper-menu selected="{{selectedContact}}">
            <template is="dom-repeat" items="{{friends}}">
              <paper-item>
                <contact-element
                  name="{{item.username}}"
                  online="{{item.online}}"
                  img="{{item.img}}">
                </contact-element>
              </paper-item>
            </template>
          </paper-menu>
        </div>
      </paper-header-panel>
      <paper-header-panel main>
        <paper-toolbar>
          <div class="title">{{generateContactName(selectedContact)}}</div>
        </paper-toolbar>
        <div id="mainContent">
          <template is="dom-if" if="{{noneSelected(selectedContact)}}">
            <div>
              <paper-material>
                  Choose a contact to view or send messages.
              </paper-material>
            </div>
          </template>
          <div>
            <paper-dialog-scrollable id="messages">
            <template is="dom-repeat" items="{{currentMessages}}">
              <paper-item>{{item.message}}</paper-item>
            </template>
          </paper-dialog-scrollable>
            <template is="dom-if" if="{{!noneSelected(selectedContact)}}">
              <div>
                <paper-input on-keydown="checkSubmit" value="{{message}}" label="send a message"></paper-input>
              </div>
            </template>
          </div>
        </div>
      </paper-header-panel>
    </paper-drawer-panel>
  </template>
  <script>
    Polymer({
      is: 'messenger-view',
      properties: {
        selectedContact: {
          type: Number,
          value: -1,
          notify: true
        },
        self: {
          type: Object
        },
        MAX_POLL_TIME: {
          type: Number,
          value: 5000 // 120 seconds
        },
        pollTime: {
          type: Number,
          value: 1000
        },
        polling: {
          type: Boolean,
          value: false
        },
        token: {
          type: String,
          value: "",
          observer: 'tokenChanged'
        },
        userId: {
          type: Number
        },
        friends: {
          type: Array,
          value: function() { return [] },
          notify: true
        },
        messages: {
          type: Array,
        },
        messagesBody: {
          type: Object,
          computed: 'computeMessagesBody(token, userId, highestReceived)'
        },
        messageBody: {
          type: Object,
          value: function() { return {}; }
        },
        highestReceived: {
          type: Number,
          value: 0
        },
        currentMessages: {
          type: Array,
          value: function() { return []; },
          readonly: false,
          readOnly: false,
          notify: true
        }
      },
      observers: [
        'friendsChanged(friends.*)',
        'friendsChanged(selectedContact)'
      ],
      friendsChanged: function(cr) {
        console.log(cr);
        this.set("currentMessages", this.computeCurrentMessages(this.selectedContact, this.friends));
        this.notifyPath("currentMessages", this.currentMessages.slice());
        this.$.messages.scrollTarget.scrollTop = this.$.messages.scrollTarget.scrollHeight
      },
      computeCurrentMessages: function(i, friends) {
        if(friends && i > friends.length || i == -1)
          return [];
        return friends[i].messages
      },
      tokenChanged: function(newValue, old) {
        if(newValue != "") {
          this.loggedIn();
          console.log(this);
          console.log("Polling for updates");
          console.log(this.messagesBody);
          console.log(this);
          this.$.friendsajax.generateRequest();
          if(!this.polling) {
            console.log("polling")
            this.polling = true;
            this.$.pollajax.generateRequest();
          }
        }
      },
      computeMessagesBody: function(token, id, h) {
        console.log(token + ":" + id);
        console.log(this.highestReceived)
        console.log(token + "\n" + id + "\n" + this.highestReceived)
        return { token: token, sender: id, highestReceived: this.highestReceived };
      },
      getMessages: function(friends, contact) {
        if(!friends || contact > friends.length || contact == -1)
          return
        return friends[contact].messages;
      },
      getSelectedFriend: function(contact) {
        return this.friends[contact]
      },
      generateContactName: function(friend) {
        console.log(friend);
        if(friend < 0)
          return "";
        return this.getSelectedFriend(friend).name;
      },
      noneSelected: function(friend) {
        if (friend < 0)
          return true;
        return false;
      },
      pollResponse: function(e, res) {
        if(this.containsError(res.response)) {
          return;
        }
        console.log(res.response);
        var asString;
        try {
          asString = JSON.stringify(res.response);
        } catch(e) {
          asString = "{}";
        }
        if(asString == "{}") {
          console.log("Increasing wait time");
          this.pollTime = Math.min(this.pollTime * 2, this.MAX_POLL_TIME)
        } else {
          console.log("Resetting wait time");
          this.pollTime = 1000;
          this.addMessagesToFriends(res.response);
        }
        var self = this;
        setTimeout(function() {
          self.$.pollajax.generateRequest();
        }, this.pollTime)
      },
      addMessagesToFriends: function(messages) {
        var ids = Object.keys(messages);
        for(var i = 0 ; i < ids.length; i++) {
          for(var j = 0 ; j < this.friends.length; j++) {
            if(ids[i] ==  this.friends[j].id) {
              if(!this.friends[j].messages)
                this.friends[j].messages = [];
              for(var k = 0; k < messages[ids[i]].length; k++) {
                console.log(messages[ids[i]][k].id)
                if(messages[ids[i]][k].id > this.highestReceived || this.highestReceived == NaN || this.highestReceived === undefined) {
                  console.log("changing highestReceived")
                  this.set("highestReceived", messages[ids[i]][k].id);
                } else {
                  console.log("not pushing %d, %d", this.highestReceived, messages[ids[i]][k].id);
                  console.log(this.highestReceived)
                }
                // this.friends[j].messages.push(messages[ids[i]][k])
                console.log("friends."+j+".messages");
                this.push("friends." + j + ".messages", messages[ids[i]][k]);
                this.notifyPath("friends", this.friends.slice());
                this.notifyPath("friends."+j+".messages", this.friends[j].messages.slice());
              }
            }
          }
        }
      },
      checkSubmit: function(e) {
        if(e.keyCode == 13) {
          this.messageBody = this.computeMessageBody()
          this.message = "";
          this.$.messageAjax.generateRequest();
        }
      },
      computeMessageBody: function() {
        console.log({ sender: this.userId, dest: this.friends[this.selectedContact].id, message: this.message, token: this.token });
        return { sender: this.userId, dest: this.friends[this.selectedContact].id, message: this.message, token: this.token }
      },
      friendsResponse: function(e, res) {
        if(res.response) {
          var tmp = res.response;
          console.log(tmp);
          this.friends = tmp;
        }
      },
      loggedIn: function() {
        // this.$.pollajax.generateRequest();
      },
      function containsError(e) {
        if(e && e.error) {
          errorHandler(e);
          return true;
        } else {
          return false;
        }
      }
      errorHandler: function(e) {
        switch(e.error) {
          case "ERROR_BAD_TOKEN":
            this.fire("relogin");
        }
      }
    })
  </script>
</dom-module>
